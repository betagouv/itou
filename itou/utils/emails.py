import re

from django.conf import settings
from django.core import mail
from django.core.mail import get_connection
from django.core.mail.backends.base import BaseEmailBackend
from django.core.mail.message import EmailMessage
from django.template.loader import get_template
from dramatiq import actor


def remove_extra_line_breaks(text):
    """
    Replaces multiple line breaks with just one.

    Useful to suppress empty line breaks generated by Django's template tags
    in emails text templates.
    """
    return re.sub(r"\n{3,}", "\n\n", text)


def get_email_text_template(template, context):
    context.update(
        {
            "itou_protocol": settings.ITOU_PROTOCOL,
            "itou_fqdn": settings.ITOU_FQDN,
            "itou_email_contact": settings.ITOU_EMAIL_CONTACT,
            "itou_environment": settings.ITOU_ENVIRONMENT,
        }
    )
    return remove_extra_line_breaks(get_template(template).render(context).strip())


def get_email_message(to, context, subject, body, from_email=settings.DEFAULT_FROM_EMAIL, bcc=None):
    subject_prefix = "[DEMO] " if settings.ITOU_ENVIRONMENT == "DEMO" else ""
    return mail.EmailMessage(
        from_email=from_email,
        to=to,
        bcc=bcc,
        subject=subject_prefix + get_email_text_template(subject, context),
        body=get_email_text_template(body, context),
    )


# EXPERIMENTAL:
# ---
# Custom async email backend wrapper


def _serializeEmailMessage(email_message):
    """
    Returns a dict with `EmailMessage` instance content serializable via Pickle (remote data sending concern).

    **Important:**
    Some important features & fields of `EmailMessage` are not "serialized":
    * attachments
    * special options of the messages

    Just the bare minimum used by the app is kept for serialization.

    This functions works in pair with `_deserializeEmailMessage`.
    """
    return {
        "subject": email_message.subject,
        "to": email_message.to,
        "from_email": email_message.from_email,
        "cc": email_message.cc,
        "bcc": email_message.bcc,
        "body": email_message.body,
    }


def _deserializeEmailMessage(serialized_email_message):
    """ 
        Creates a "light" version of the original `EmailMessage` passed to the email backend.

        In order to be serializable, we:
        * only get the fields actually used by the app (defined in counterpart `_serializeEmailMessage`)
        * add a reference to the "synchronous" email backend (for convenience)

        *Tip*: use non-serializable objects only when deserialization is over... (f.i. email backends)
    """
    return EmailMessage(connection=get_connection(backend=settings.ASYNC_EMAIL_BACKEND), **serialized_email_message)


@actor(max_retries=settings.SEND_EMAIL_NB_RETRIES)
def _async_send_messages(serializable_email_messages):
    """ Async email sending "delegate" 

        This function sends emails with the backend defined in `settings.ASYNC_EMAIL_BACKEND`
        and is trigerred by an email backend wrappper: `AsyncEmailBackend`.

        As it is decorated as a Dramatiq actor, all parameters must be serializable via a JSON dump.

        Huey stores some data via the broker persistance mechanism (Redis | RabbitMQ)
        for RPC/async/retry purposes.

        In order to send data to a remote broker and perform callback function call on the client,
        Huey must use a serialization mechanism to send "over the wire" (Pickle here).

        In this case for a `@actor`, data sent by Huey are:
        * the function name (to use as a callback)
        * its call parameters (to make the call)

        The main parameter is a list of `EmailMessage` objects to be send.

        By design, an `EmailMessage` instance holds references to some non-serializable ressources:
        * a connection to the email backend (if not `None`)
        * inner locks for atomic/threadsafe operations
        * ...

        Making `EmailMessage` serializable is the purpose of `_serializeEmailMessage` and `_deserializeEmailMessage`.

        If there are many async tasks to be defined or for specific objects,
        it may be better to use a custom serializer.

        By design, this function must return the number of email correctly processed.
    """

    count = 0

    for message in [_deserializeEmailMessage(email) for email in serializable_email_messages]:
        message.send()
        count += 1

    return count


class AsyncEmailBackend(BaseEmailBackend):
    """ Custom async email backend wrapper

        Decorating a method with `@task` does not work (no static context).
        Only functions can be Huey tasks.

        This class:
        * wraps an email backend defined in `settings.ASYNC_EMAIL_BACKEND`
        * delegate the actual email sending to a function with *serializable* parameters 

        See:
        * `base.py` section "Dramatiq" for details on `ASYNC_EMAIL_BACKEND`
        * `_async_send_messages` for more on details on async/serialization concerns
    """

    def send_messages(self, email_messages):
        # Turn emails into something serializable
        if not email_messages:
            return

        emails = [_serializeEmailMessage(email) for email in email_messages]

        return _async_send_messages(emails)
